// This component is almost totally generated by AI.
import {
  Box,
  Button,
  HStack,
  Modal,
  ModalBody,
  ModalCloseButton,
  ModalContent,
  ModalFooter,
  ModalHeader,
  ModalOverlay,
  Step,
  StepIndicator,
  StepSeparator,
  StepStatus,
  Stepper,
  Text,
  useDisclosure,
  useToken,
} from "@chakra-ui/react";
import React, {
  ReactNode,
  createContext,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";
import { useTranslation } from "react-i18next";
import { useLauncherConfig } from "@/contexts/config";

export type Placement = "top" | "right" | "bottom" | "left";

type TourStep = {
  id: string;
  title?: string;
  content: ReactNode;
  placement?: Placement;
  padding?: number;
  radius?: number;
};

type HoleRect = {
  top: number;
  left: number;
  width: number;
  height: number;
} | null;

type TourContextType = {
  startGuidedTour: (initialStep?: number) => void;
  next: () => void;
  prev: () => void;
  close: () => void;
  isOpen: boolean;
  index: number;
};

const TourContext = createContext<TourContextType | null>(null);

type TourProviderProps = {
  children: ReactNode;
  defaultPadding?: number; // mask hole padding
  defaultRadius?: number; // mask hole corner radius
  maxModalWidth?: number; // guide modal max width
  overlayColorToken?: string;
  modalGap?: number; // gap between mask hole and modal
  transitionMs?: number; // transition duration in ms
};

export const GuidedTourProvider: React.FC<TourProviderProps> = ({
  children,
  defaultPadding = 12,
  defaultRadius = 2,
  maxModalWidth = 360,
  overlayColorToken = "blackAlpha.600",
  modalGap = 8,
  transitionMs = 240,
}) => {
  const { t } = useTranslation();
  const { isOpen, onOpen, onClose } = useDisclosure();
  const { config } = useLauncherConfig();
  const primaryColor = config.appearance.theme.primaryColor as string;

  const [index, setIndex] = useState(0);
  const [overlayColor] = useToken("colors", [overlayColorToken]);
  const [overlayZ] = useToken("zIndices", ["modal"]);

  const [holeRect, setHoleRect] = useState<HoleRect>(null);
  const contentRef = useRef<HTMLDivElement>(null);
  const [contentPos, setContentPos] = useState<{
    top: number;
    left: number;
    p: Placement;
  }>({
    top: 0,
    left: 0,
    p: "bottom",
  });

  const [animate, setAnimate] = useState(true);

  const STEPS: TourStep[] = [
    {
      id: "head-navbar-tab-instances",
      title: t("GuidedTourProvider.step1.title"),
      content: t("GuidedTourProvider.step1.content"),
      placement: "bottom",
    },
    {
      id: "head-navbar-tab-accounts",
      title: t("GuidedTourProvider.step2.title"),
      content: t("GuidedTourProvider.step2.content"),
      placement: "bottom",
    },
    {
      id: "main-launch-button",
      title: t("GuidedTourProvider.step3.title"),
      content: t("GuidedTourProvider.step3.content"),
      placement: "bottom",
    },
  ];

  const current = STEPS[index] ?? null;
  const lastIndex = STEPS.length - 1;

  const rafRef = useRef<number | null>(null);
  const schedule = useCallback((fn: () => void) => {
    if (rafRef.current != null) return;
    rafRef.current = requestAnimationFrame(() => {
      rafRef.current = null;
      fn();
    });
  }, []);

  const start = useCallback(
    (initialStep = 0) => {
      setIndex(Math.max(0, Math.min(initialStep, STEPS.length - 1)));
      onOpen();
    },
    [onOpen, STEPS.length]
  );

  const close = useCallback(() => {
    onClose();
    setIndex(0);
  }, [onClose]);

  const prev = useCallback(() => setIndex((i) => Math.max(0, i - 1)), []);
  const next = useCallback(() => {
    setIndex((i) => {
      if (i + 1 < STEPS.length) return i + 1;
      close();
      return i;
    });
  }, [close, STEPS.length]);

  const clamp = (n: number, min: number, max: number) =>
    Math.max(min, Math.min(max, n));
  const getTarget = useCallback(
    () => (current?.id ? document.getElementById(current.id) : null),
    [current?.id]
  );

  // calc mask hole and modal position in the same frame
  const computeLayout = useCallback(() => {
    const t = getTarget();
    if (!t) {
      if (holeRect !== null) setHoleRect(null);
      return;
    }

    const r = t.getBoundingClientRect();
    const pad = current?.padding ?? defaultPadding;

    const hole = {
      top: Math.max(0, r.top - pad),
      left: Math.max(0, r.left - pad),
      width: r.width + pad * 2,
      height: r.height + pad * 2,
    };

    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const modalW = contentRef.current?.offsetWidth ?? maxModalWidth;
    const modalH = contentRef.current?.offsetHeight ?? 180;
    const seed: Placement = current?.placement ?? "bottom";

    const tryBottom = () => ({
      top: hole.top + hole.height + modalGap,
      left: clamp(hole.left + hole.width / 2 - modalW / 2, 8, vw - modalW - 8),
      p: "bottom" as Placement,
    });
    const tryTop = () => ({
      top: hole.top - modalH - modalGap,
      left: clamp(hole.left + hole.width / 2 - modalW / 2, 8, vw - modalW - 8),
      p: "top" as Placement,
    });
    const tryRight = () => ({
      top: clamp(hole.top + hole.height / 2 - modalH / 2, 8, vh - modalH - 8),
      left: hole.left + hole.width + modalGap,
      p: "right" as Placement,
    });
    const tryLeft = () => ({
      top: clamp(hole.top + hole.height / 2 - modalH / 2, 8, vh - modalH - 8),
      left: hole.left - modalW - modalGap,
      p: "left" as Placement,
    });

    const order =
      seed === "top"
        ? [tryTop, tryBottom, tryRight, tryLeft]
        : seed === "right"
          ? [tryRight, tryLeft, tryBottom, tryTop]
          : seed === "left"
            ? [tryLeft, tryRight, tryBottom, tryTop]
            : [tryBottom, tryTop, tryRight, tryLeft];

    const fits = (pos: { top: number; left: number }) =>
      pos.left >= 0 &&
      pos.top >= 0 &&
      pos.left + modalW <= vw &&
      pos.top + modalH <= vh;

    let chosen = order[0]();
    if (!fits(chosen)) {
      for (let i = 1; i < order.length; i++) {
        const cand = order[i]();
        if (fits(cand)) {
          chosen = cand;
          break;
        }
      }
    }

    setHoleRect((prev) => {
      if (
        prev &&
        prev.top === hole.top &&
        prev.left === hole.left &&
        prev.width === hole.width &&
        prev.height === hole.height
      )
        return prev;
      return hole;
    });

    setContentPos((prev) => {
      if (
        prev &&
        prev.top === chosen.top &&
        prev.left === chosen.left &&
        prev.p === chosen.p
      )
        return prev;
      return chosen;
    });
  }, [
    getTarget,
    current?.padding,
    current?.placement,
    defaultPadding,
    maxModalWidth,
    modalGap,
    holeRect,
  ]);

  useEffect(() => {
    if (!isOpen || !current) return;
    schedule(() => computeLayout());
  }, [isOpen, current, index, schedule, computeLayout]);

  // robust resize/scroll handling
  useEffect(() => {
    if (!isOpen) return;

    let debounceId: number | null = null;

    const handleResizeSync = () => {
      if (debounceId) window.clearTimeout(debounceId);
      if (animate) setAnimate(false);
      computeLayout();
      debounceId = window.setTimeout(() => {
        setAnimate(true);
        computeLayout();
        debounceId = null;
      }, 120);
    };

    const handleScroll = () => {
      schedule(() => computeLayout());
    };

    window.addEventListener("resize", handleResizeSync);
    window.addEventListener("scroll", handleScroll, true);

    const vv = window.visualViewport;
    vv?.addEventListener("resize", handleResizeSync);
    vv?.addEventListener("scroll", handleResizeSync);

    return () => {
      window.removeEventListener("resize", handleResizeSync);
      window.removeEventListener("scroll", handleScroll, true);
      vv?.removeEventListener("resize", handleResizeSync);
      vv?.removeEventListener("scroll", handleResizeSync);
      if (debounceId) window.clearTimeout(debounceId);
      if (rafRef.current) cancelAnimationFrame(rafRef.current);
    };
  }, [isOpen, computeLayout, schedule, animate]);

  // observe target and modal size changes
  useEffect(() => {
    if (!isOpen) return;
    const target = getTarget();
    const ro = new ResizeObserver(() => computeLayout());
    if (target) ro.observe(target);
    if (contentRef.current) ro.observe(contentRef.current);
    return () => ro.disconnect();
  }, [isOpen, getTarget, computeLayout]);

  const ctx = useMemo<TourContextType>(
    () => ({ startGuidedTour: start, next, prev, close, isOpen, index }),
    [start, next, prev, close, isOpen, index]
  );

  const showModal = Boolean(isOpen && current && holeRect);

  return (
    <TourContext.Provider value={ctx}>
      {children}

      <Modal
        isOpen={isOpen}
        onClose={close}
        isCentered={false}
        closeOnOverlayClick={false}
        blockScrollOnMount
        trapFocus
        // disable default animations in next steps
        motionPreset={index ? "none" : "scale"}
      >
        <MaskedOverlay
          holeRect={holeRect}
          cornerRadius={current?.radius ?? defaultRadius}
          overlayColor={overlayColor}
          transitionMs={animate ? transitionMs : 0}
        />

        {showModal && (
          <ModalContent
            ref={contentRef}
            position="fixed"
            top={contentPos.top}
            left={contentPos.left}
            transform="none"
            maxW={`${maxModalWidth}px`}
            zIndex={Number(overlayZ) + 1}
            m={0}
            _focusVisible={{ outline: "none" }}
            sx={{
              transitionProperty: "top, left",
              transitionDuration: `${animate ? transitionMs : 0}ms`,
              transitionTimingFunction: "cubic-bezier(.2,.8,.2,1)",
            }}
          >
            <ModalCloseButton />

            <ModalHeader>{current?.title ?? `Step ${index + 1}`}</ModalHeader>

            <ModalBody>
              <Text>{current?.content}</Text>
            </ModalBody>

            <ModalFooter w="100%">
              <DotStepper total={STEPS.length} active={index} />

              <HStack spacing={2} ml="auto">
                {index !== lastIndex && (
                  <Button size="sm" variant="ghost" onClick={close}>
                    {t("General.skip")}
                  </Button>
                )}
                {index > 0 && (
                  <Button size="sm" variant="ghost" onClick={prev}>
                    {t("General.previous")}
                  </Button>
                )}
                <Button size="sm" colorScheme={primaryColor} onClick={next}>
                  {index === lastIndex
                    ? t("General.finish")
                    : t("General.next")}
                </Button>
              </HStack>
            </ModalFooter>
          </ModalContent>
        )}
      </Modal>
    </TourContext.Provider>
  );
};

type MaskedOverlayProps = {
  holeRect: HoleRect;
  cornerRadius?: number;
  overlayColor?: string;
  transitionMs?: number;
};

const MaskedOverlay: React.FC<MaskedOverlayProps> = ({
  holeRect,
  cornerRadius = 2,
  overlayColor = "rgba(0,0,0,0.6)",
  transitionMs = 160,
}) => {
  const radius = holeRect
    ? Math.min(cornerRadius, holeRect.width / 2, holeRect.height / 2)
    : cornerRadius;

  return (
    <ModalOverlay bg="transparent">
      <Box
        as="svg"
        position="fixed"
        inset={0}
        width="100vw"
        height="100vh"
        pointerEvents="none"
      >
        <defs>
          <mask id="tour-hole-mask">
            <rect x="0" y="0" width="100%" height="100%" fill="white" />
            {holeRect && (
              <rect
                x={holeRect.left}
                y={holeRect.top}
                width={holeRect.width}
                height={holeRect.height}
                rx={radius}
                ry={radius}
                fill="black"
                style={{
                  transition: [
                    `x ${transitionMs}ms cubic-bezier(.2,.8,.2,1)`,
                    `y ${transitionMs}ms cubic-bezier(.2,.8,.2,1)`,
                    `width ${transitionMs}ms cubic-bezier(.2,.8,.2,1)`,
                    `height ${transitionMs}ms cubic-bezier(.2,.8,.2,1)`,
                    `rx ${transitionMs}ms cubic-bezier(.2,.8,.2,1)`,
                    `ry ${transitionMs}ms cubic-bezier(.2,.8,.2,1)`,
                  ].join(", "),
                }}
              />
            )}
          </mask>
        </defs>
        <rect
          x="0"
          y="0"
          width="100%"
          height="100%"
          fill={overlayColor}
          mask="url(#tour-hole-mask)"
        />
      </Box>
    </ModalOverlay>
  );
};

type DotStepperProps = {
  total: number;
  active: number;
};

const DotStepper: React.FC<DotStepperProps> = ({ total, active }) => {
  const { config } = useLauncherConfig();
  const primaryColor = config.appearance.theme.primaryColor;

  return (
    <Stepper index={active} size="xs" gap="0" colorScheme={primaryColor}>
      {Array.from({ length: total }).map((_, i) => (
        <Step key={i}>
          <StepIndicator w="10px" h="10px" p="0" borderRadius="full">
            <StepStatus />
          </StepIndicator>
          <StepSeparator _horizontal={{ mx: "0.5" }} />
        </Step>
      ))}
    </Stepper>
  );
};

export const useGuidedTour = () => {
  const ctx = useContext(TourContext);
  if (!ctx)
    throw new Error("useGuidedTour must be used within <GuidedTourProvider>");
  return ctx;
};
